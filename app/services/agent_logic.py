"""
L√≥gica principal do agente de reservas
"""
from datetime import datetime, timedelta
from typing import Optional
import logging

from app.utils.nlu import nlu_processor
from app.services.whatsapp_service import whatsapp_service
from app.services.groq_llm_service import groq_llm_service
from app.repositories.users_repo import users_repo
from app.repositories.courts_repo import courts_repo
from app.repositories.reservations_repo import reservations_repo
from app.models.user import UserCreate
from app.models.reservation import ReservationCreate

logger = logging.getLogger(__name__)


class AgentLogic:
    """L√≥gica principal do agente de reservas"""
    
    def __init__(self):
        self.nlu = nlu_processor
        self.whatsapp = whatsapp_service
        self.llm = groq_llm_service
    
    async def process_message(self, phone: str, message: str) -> str:
        """
        Processa mensagem do usu√°rio usando abordagem h√≠brida (NLU + LLM)
        
        Args:
            phone: N√∫mero do telefone do usu√°rio
            message: Mensagem recebida
            
        Returns:
            str: Resposta do agente
        """
        try:
            # Busca ou cria usu√°rio primeiro
            user = await users_repo.find_or_create_by_phone(phone, "Usu√°rio")
            
            # 1. Tenta processar com NLU tradicional primeiro
            nlu_data = self.nlu.process_message(message)
            intent = nlu_data["intent"]
            
            logger.info(f"NLU identificou inten√ß√£o: {intent}")
            
            # 2. Se NLU conseguiu identificar uma inten√ß√£o clara, usa l√≥gica tradicional
            if intent != "indefinida" and intent in ["saudacao", "ajuda", "reservar", "consultar", "cancelar"]:
                logger.info("Usando l√≥gica tradicional NLU")
                return await self._handle_with_traditional_logic(user, nlu_data)
            
            # 3. Se NLU n√£o conseguiu identificar, tenta LLM ou usa fallback
            if intent == "indefinida":
                if self.llm.is_available():
                    logger.info("Usando LLM para processar mensagem indefinida")
                    return await self._handle_with_llm(user, message, nlu_data)
                else:
                    # Fallback para l√≥gica tradicional se LLM n√£o dispon√≠vel
                    logger.info("LLM n√£o dispon√≠vel, usando l√≥gica tradicional para mensagem indefinida")
                    return await self._handle_unknown_intent(user, message)
            else:
                # Se NLU identificou uma inten√ß√£o v√°lida, usa l√≥gica tradicional
                logger.info("Usando l√≥gica tradicional para inten√ß√£o identificada")
                return await self._handle_with_traditional_logic(user, nlu_data)
                
        except Exception as e:
            logger.error(f"Erro ao processar mensagem: {e}")
            return "‚ùå Ops! Algo deu errado. Tente novamente ou digite 'ajuda' para ver as op√ß√µes dispon√≠veis."
    
    async def _handle_with_traditional_logic(self, user, nlu_data: dict) -> str:
        """Processa mensagem usando l√≥gica tradicional NLU"""
        intent = nlu_data["intent"]
        
        if intent == "saudacao":
            return await self._handle_greeting(user)
        elif intent == "ajuda":
            return await self._handle_help(user)
        elif intent == "reservar":
            return await self._handle_reservation(user, nlu_data)
        elif intent == "confirmar":
            return await self._handle_confirmation(user, nlu_data)
        elif intent == "consultar":
            return await self._handle_list_reservations(user)
        elif intent == "cancelar":
            return await self._handle_cancel_reservation(user, nlu_data)
        elif intent == "disponibilidade":
            return await self._handle_availability(nlu_data)
        else:
            return await self._handle_unknown_intent(user, nlu_data["original_message"])
    
    async def _handle_with_llm(self, user, message: str, nlu_data: dict) -> str:
        """Processa mensagem usando LLM"""
        try:
            # Prepara contexto adicional
            context = {
                "user_name": user.nome,
                "user_phone": user.telefone,
                "nlu_data": nlu_data
            }
            
            # Usa LLM para processar a mensagem
            llm_response = await self.llm.process_with_llm(message, user.telefone, context)
            
            # Se o LLM sugerir uma a√ß√£o espec√≠fica (como reservar), executa a l√≥gica tradicional
            if self._should_execute_action(llm_response, nlu_data):
                logger.info("LLM sugeriu a√ß√£o espec√≠fica, executando l√≥gica tradicional")
                return await self._handle_with_traditional_logic(user, nlu_data)
            
            return llm_response
            
        except Exception as e:
            logger.error(f"Erro ao processar com LLM: {e}")
            # Fallback para l√≥gica tradicional
            return await self._handle_with_traditional_logic(user, nlu_data)
    
    def _should_execute_action(self, llm_response: str, nlu_data: dict) -> bool:
        """Verifica se o LLM sugeriu uma a√ß√£o que deve ser executada pela l√≥gica tradicional"""
        # Se NLU j√° identificou uma inten√ß√£o clara de a√ß√£o, executa
        if nlu_data["intent"] in ["reservar", "consultar", "cancelar"]:
            return True
        
        # Para mensagens indefinidas, n√£o executa a√ß√£o tradicional
        # Deixa o LLM responder diretamente
        return False
    
    async def _handle_greeting(self, user) -> str:
        """Processa sauda√ß√µes"""
        return f"""Ol√° {user.nome}! üëã

Bem-vindo ao sistema de reservas de quadras! 

Posso te ajudar com:
üèüÔ∏è Reservar uma quadra
üìã Consultar suas reservas  
‚ùå Cancelar uma reserva
üìÖ Ver hor√°rios dispon√≠veis

Como posso te ajudar hoje?"""
    
    async def _handle_help(self, user) -> str:
        """Processa pedidos de ajuda"""
        return """üìã *Como usar o sistema:*

üèüÔ∏è *Para reservar:*
"Quero reservar uma quadra de futebol amanh√£ √†s 18h"

üìÖ *Para consultar:*
"Quais s√£o minhas reservas?"

‚ùå *Para cancelar:*
"Quero cancelar minha reserva de amanh√£ √†s 18h"

üìã *Para ver disponibilidade:*
"Que hor√°rios est√£o livres hoje?"

Digite sua solicita√ß√£o em linguagem natural! üòä"""
    
    async def _handle_reservation(self, user, data: dict) -> str:
        """Processa solicita√ß√µes de reserva"""
        try:
            # Verifica se tem dados suficientes
            if not data.get("datetime"):
                return """‚ùå Preciso saber quando voc√™ quer reservar!

Por favor, especifique:
- Tipo de quadra (futebol, futsal, v√¥lei, etc.)
- Data (hoje, amanh√£, ou data espec√≠fica)
- Hor√°rio (ex: 18h, 19:30)

Exemplo: "Quero reservar uma quadra de futebol amanh√£ √†s 18h" """
            
            reservation_datetime = data["datetime"]
            court_type = data.get("court_type", "futebol")
            hours_quantity = data.get("hours_quantity", 1)
            
            # Busca quadras dispon√≠veis
            available_courts = await courts_repo.get_available_at_time(reservation_datetime)
            
            if not available_courts:
                return f"‚ùå Nenhuma quadra dispon√≠vel em {reservation_datetime.strftime('%d/%m √†s %H:%M')}.\n\nTente outro hor√°rio ou digite 'disponibilidade' para ver hor√°rios livres."
            
            # Filtra por tipo se especificado
            if court_type:
                available_courts = [court for court in available_courts 
                                 if court_type.lower() in court.tipo.lower()]
            
            if not available_courts:
                return f"‚ùå Nenhuma quadra de {court_type} dispon√≠vel em {reservation_datetime.strftime('%d/%m √†s %H:%M')}.\n\nTente outro tipo de quadra ou hor√°rio."
            
            # Pega a primeira quadra dispon√≠vel
            selected_court = available_courts[0]
            
            # Calcula valores
            valor_hora = selected_court.valor_hora
            valor_total = valor_hora * hours_quantity
            
            # Verifica se j√° existe reserva para este usu√°rio no mesmo hor√°rio
            existing_reservation = await reservations_repo.get_by_court_and_time(
                selected_court.id, reservation_datetime
            )
            
            if existing_reservation and existing_reservation.usuario.telefone == user.telefone:
                return f"‚úÖ Voc√™ j√° tem uma reserva confirmada para {reservation_datetime.strftime('%d/%m √†s %H:%M')} na {selected_court.nome}!"
            
            # Mostra confirma√ß√£o de pre√ßo antes de criar a reserva
            return f"""üí∞ *Confirma√ß√£o de Reserva*

üèüÔ∏è Quadra: {selected_court.nome}
‚öΩ Tipo: {selected_court.tipo}
üìÖ Data: {reservation_datetime.strftime('%d/%m/%Y')}
üïê Hor√°rio: {reservation_datetime.strftime('%H:%M')}
‚è∞ Dura√ß√£o: {hours_quantity} hora{'s' if hours_quantity > 1 else ''}
üí∞ Valor/hora: R$ {valor_hora:.2f}
üíµ Valor total: R$ {valor_total:.2f}

Para confirmar, digite: 'confirmar reserva'
Para cancelar, digite: 'cancelar'"""
            
        except Exception as e:
            logger.error(f"Erro ao processar reserva: {e}")
            return "‚ùå Erro ao processar sua reserva. Tente novamente."
    
    async def _handle_confirmation(self, user, data: dict) -> str:
        """Processa confirma√ß√£o de reserva"""
        try:
            # Por enquanto, vamos implementar uma vers√£o simples
            # Em uma vers√£o mais avan√ßada, poder√≠amos armazenar dados tempor√°rios
            return """‚ùå Confirma√ß√£o n√£o implementada ainda.

Por favor, fa√ßa uma nova solicita√ß√£o de reserva com todos os detalhes:
"Quero reservar uma quadra de futebol amanh√£ √†s 18h por 2 horas"

Em breve implementaremos o sistema de confirma√ß√£o! üöÄ"""
            
        except Exception as e:
            logger.error(f"Erro ao processar confirma√ß√£o: {e}")
            return "‚ùå Erro ao processar confirma√ß√£o. Tente novamente."
    
    async def _handle_list_reservations(self, user) -> str:
        """Lista reservas do usu√°rio"""
        try:
            reservations = await reservations_repo.get_by_user_phone(user.telefone)
            
            if not reservations:
                return "üìã Voc√™ n√£o tem nenhuma reserva confirmada no momento.\n\nPara fazer uma reserva, digite algo como: 'Quero reservar uma quadra de futebol amanh√£ √†s 18h'"
            
            response = f"üìã *Suas reservas:*\n\n"
            
            for i, reservation in enumerate(reservations, 1):
                response += f"{i}. üèüÔ∏è {reservation.quadra_nome}\n"
                response += f"   ‚öΩ {reservation.quadra_tipo}\n"
                response += f"   üìÖ {reservation.data_reserva.strftime('%d/%m/%Y √†s %H:%M')}\n"
                response += f"   üí∞ R$ {reservation.valor_hora:.2f}/hora\n"
                response += f"   üìä Status: {reservation.status.title()}\n\n"
            
            response += "Para cancelar uma reserva, digite: 'Quero cancelar minha reserva de [data] √†s [hora]'"
            
            return response
            
        except Exception as e:
            logger.error(f"Erro ao listar reservas: {e}")
            return "‚ùå Erro ao consultar suas reservas. Tente novamente."
    
    async def _handle_cancel_reservation(self, user, data: dict) -> str:
        """Processa cancelamento de reserva"""
        try:
            if not data.get("datetime"):
                return """‚ùå Para cancelar uma reserva, preciso saber qual!

Por favor, especifique a data e hor√°rio da reserva que deseja cancelar.

Exemplo: "Quero cancelar minha reserva de amanh√£ √†s 18h" """
            
            reservation_datetime = data["datetime"]
            
            # Cancela a reserva
            success = await reservations_repo.cancel_by_user_and_time(
                user.telefone, reservation_datetime
            )
            
            if success:
                return f"‚úÖ Reserva cancelada com sucesso!\n\nüìÖ Data cancelada: {reservation_datetime.strftime('%d/%m √†s %H:%M')}\n\nPara fazer uma nova reserva, √© s√≥ me avisar! üòä"
            else:
                return f"‚ùå N√£o encontrei nenhuma reserva sua para {reservation_datetime.strftime('%d/%m √†s %H:%M')}.\n\nVerifique os dados e tente novamente."
            
        except Exception as e:
            logger.error(f"Erro ao cancelar reserva: {e}")
            return "‚ùå Erro ao cancelar reserva. Tente novamente."
    
    async def _handle_availability(self, data: dict) -> str:
        """Mostra hor√°rios dispon√≠veis"""
        try:
            # Busca todas as quadras
            all_courts = await courts_repo.get_all()
            
            if not all_courts:
                return "‚ùå Nenhuma quadra cadastrada no sistema."
            
            response = "üìÖ *Hor√°rios dispon√≠veis:*\n\n"
            
            # Agrupa por tipo de quadra
            courts_by_type = {}
            for court in all_courts:
                court_type = court.tipo
                if court_type not in courts_by_type:
                    courts_by_type[court_type] = []
                courts_by_type[court_type].append(court)
            
            for court_type, courts in courts_by_type.items():
                response += f"‚öΩ *{court_type.upper()}*\n"
                
                for court in courts:
                    if court.horarios_disponiveis:
                        response += f"  üèüÔ∏è {court.nome}:\n"
                        for horario in sorted(court.horarios_disponiveis):
                            response += f"    ‚Ä¢ {horario.strftime('%d/%m √†s %H:%M')}\n"
                        response += f"    üí∞ R$ {court.valor_hora:.2f}/hora\n\n"
                    else:
                        response += f"  üèüÔ∏è {court.nome}: Sem hor√°rios dispon√≠veis\n"
                        response += f"    üí∞ R$ {court.valor_hora:.2f}/hora\n\n"
            
            response += "Para reservar, digite: 'Quero reservar uma quadra de [tipo] [data] √†s [hora]'"
            
            return response
            
        except Exception as e:
            logger.error(f"Erro ao consultar disponibilidade: {e}")
            return "‚ùå Erro ao consultar disponibilidade. Tente novamente."
    
    async def _handle_unknown_intent(self, user, message: str) -> str:
        """Processa inten√ß√µes n√£o reconhecidas"""
        return f"""ü§î N√£o entendi sua solicita√ß√£o: "{message}"

Posso te ajudar com:
üèüÔ∏è Reservar uma quadra
üìã Consultar suas reservas
‚ùå Cancelar uma reserva  
üìÖ Ver hor√°rios dispon√≠veis

Digite 'ajuda' para ver exemplos de como usar o sistema! üòä"""


# Inst√¢ncia global da l√≥gica do agente
agent_logic = AgentLogic()
